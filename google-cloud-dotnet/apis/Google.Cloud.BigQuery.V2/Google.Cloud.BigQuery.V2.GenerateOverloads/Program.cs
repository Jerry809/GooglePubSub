// Copyright 2017 Google Inc. All Rights Reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Linq;

namespace Google.Cloud.BigQuery.V2.GenerateOverloads
{
    /// <summary>
    /// BigQuery-specific overload generator.
    /// </summary>
    /// <remarks>
    /// <para>
    /// The BigQuery library ends up with a lot of very similar methods, varying by how a dataset/job/table is specified,
    /// and whether or not it's asynchronous. This generator allows the description to be written a single time and then used
    /// to generate all the overloads. XML is chosen as the file format as most of the definition is in terms of XML documentation.
    /// </para>
    /// <para>
    /// For ease of later regeneration, files are checked into source control. The generation process is still run manually though.
    /// It can be rerun for the same source file, and the code will be replaced using region markers to indicate where methods are defined.
    /// If manual changes are required, they will need to be reperformed each time the generator is run. Ideally, make the generator smarter instead.
    /// TODO: Have some way of making the tool prompt for this...
    /// </para>
    /// <para>
    /// This generator only handles the async + entity referencing overloads. Where multiple overloads have different parameter types
    /// (e.g. UploadJson with Stream and String[] parameters) these would be generated from multiple XML files.
    /// </para>
    /// </remarks>
    class Program
    {
        private static int Main(string[] args)
        {
            if (args.Length != 2)
            {
                Console.WriteLine("Arguments: <xml filename> <source file>");
                return 1;
            }

            try
            {
                XDocument document = XDocument.Load(args[0]);
                var code = File.ReadLines(args[1]);
                foreach (var methodElement in document.Root.Elements("Method"))
                {
                    ApiMethod method = new ApiMethod(methodElement);
                    code = ModifyCode(method, code);
                }
                File.WriteAllLines(args[1], code);
                return 0;
            }
            catch (Exception e)
            {
                Console.WriteLine($"Error: {e}");
                return 1;
            }
        }

        private static IEnumerable<string> ModifyCode(ApiMethod method, IEnumerable<string> existingCode)
        {
            List<string> code = existingCode.ToList();
            List<string> generatedCode = method.GenerateCode();

            string regionLabel = method.RegionLabel;
            generatedCode.Insert(0, $"        #region {regionLabel} (autogenerated - do not edit manually)");
            generatedCode.Add("        #endregion");

            int insertionPoint = RemoveRegionAndFindInsertionPoint($"#region {regionLabel}", code);
            code.InsertRange(insertionPoint, generatedCode);
            return code;
        }

        /// <summary>
        /// Attempts to find the specified region within the specified list of lines, and removes it if it's found.
        /// In that case, the returned value is the line where the region previously started. Otherwise, it's the containing
        /// the penultimate closing brace - after an empty line is added.
        /// </summary>
        /// <param name="regionPrefix">Line indicating the prefix that identifies the region</param>
        /// <param name="code">Code to search in (and modify)</param>
        /// <returns>The position to insert the new region.</returns>
        private static int RemoveRegionAndFindInsertionPoint(string regionPrefix, List<string> code)
        {
            // Don't require an exact match, so that it's easy to go from manual to automated.
            int regionStart = code.FindIndex(line => line.TrimStart().StartsWith(regionPrefix));
            if (regionStart != -1)
            {
                int regionEnd = code.FindIndex(regionStart, line => line.Trim() == "#endregion");
                if (regionEnd == -1)
                {
                    throw new Exception($"Code contained '{regionPrefix}' but no #endregion");
                }
                code.RemoveRange(regionStart, (regionEnd - regionStart) + 1);
                return regionStart;
            }
            int lastBrace = code.FindLastIndex(line => line.Contains('}'));
            if (lastBrace < 1)
            {
                throw new Exception("File doesn't contain enough close braces");
            }
            int penultimateBrace = code.FindLastIndex(lastBrace - 1, line => line.Contains('}'));
            if (penultimateBrace == -1)
            {
                throw new Exception("File doesn't contain enough close braces");
            }
            code.Insert(penultimateBrace, "");
            return penultimateBrace + 1;
        }
    }
}