// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/logging/v2/logging_config.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Google.Cloud.Logging.V2 {

  /// <summary>Holder for reflection information generated from google/logging/v2/logging_config.proto</summary>
  public static partial class LoggingConfigReflection {

    #region Descriptor
    /// <summary>File descriptor for google/logging/v2/logging_config.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static LoggingConfigReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiZnb29nbGUvbG9nZ2luZy92Mi9sb2dnaW5nX2NvbmZpZy5wcm90bxIRZ29v",
            "Z2xlLmxvZ2dpbmcudjIaHGdvb2dsZS9hcGkvYW5ub3RhdGlvbnMucHJvdG8a",
            "G2dvb2dsZS9wcm90b2J1Zi9lbXB0eS5wcm90bxofZ29vZ2xlL3Byb3RvYnVm",
            "L3RpbWVzdGFtcC5wcm90byLXAgoHTG9nU2luaxIMCgRuYW1lGAEgASgJEhMK",
            "C2Rlc3RpbmF0aW9uGAMgASgJEg4KBmZpbHRlchgFIAEoCRJHChVvdXRwdXRf",
            "dmVyc2lvbl9mb3JtYXQYBiABKA4yKC5nb29nbGUubG9nZ2luZy52Mi5Mb2dT",
            "aW5rLlZlcnNpb25Gb3JtYXQSFwoPd3JpdGVyX2lkZW50aXR5GAggASgJEhgK",
            "EGluY2x1ZGVfY2hpbGRyZW4YCSABKAgSLgoKc3RhcnRfdGltZRgKIAEoCzIa",
            "Lmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASLAoIZW5kX3RpbWUYCyABKAsy",
            "Gi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wIj8KDVZlcnNpb25Gb3JtYXQS",
            "HgoaVkVSU0lPTl9GT1JNQVRfVU5TUEVDSUZJRUQQABIGCgJWMhABEgYKAlYx",
            "EAIiSQoQTGlzdFNpbmtzUmVxdWVzdBIOCgZwYXJlbnQYASABKAkSEgoKcGFn",
            "ZV90b2tlbhgCIAEoCRIRCglwYWdlX3NpemUYAyABKAUiVwoRTGlzdFNpbmtz",
            "UmVzcG9uc2USKQoFc2lua3MYASADKAsyGi5nb29nbGUubG9nZ2luZy52Mi5M",
            "b2dTaW5rEhcKD25leHRfcGFnZV90b2tlbhgCIAEoCSIjCg5HZXRTaW5rUmVx",
            "dWVzdBIRCglzaW5rX25hbWUYASABKAkibQoRQ3JlYXRlU2lua1JlcXVlc3QS",
            "DgoGcGFyZW50GAEgASgJEigKBHNpbmsYAiABKAsyGi5nb29nbGUubG9nZ2lu",
            "Zy52Mi5Mb2dTaW5rEh4KFnVuaXF1ZV93cml0ZXJfaWRlbnRpdHkYAyABKAgi",
            "cAoRVXBkYXRlU2lua1JlcXVlc3QSEQoJc2lua19uYW1lGAEgASgJEigKBHNp",
            "bmsYAiABKAsyGi5nb29nbGUubG9nZ2luZy52Mi5Mb2dTaW5rEh4KFnVuaXF1",
            "ZV93cml0ZXJfaWRlbnRpdHkYAyABKAgiJgoRRGVsZXRlU2lua1JlcXVlc3QS",
            "EQoJc2lua19uYW1lGAEgASgJMv4ECg9Db25maWdTZXJ2aWNlVjISfQoJTGlz",
            "dFNpbmtzEiMuZ29vZ2xlLmxvZ2dpbmcudjIuTGlzdFNpbmtzUmVxdWVzdBok",
            "Lmdvb2dsZS5sb2dnaW5nLnYyLkxpc3RTaW5rc1Jlc3BvbnNlIiWC0+STAh8S",
            "HS92Mi97cGFyZW50PXByb2plY3RzLyp9L3NpbmtzEnQKB0dldFNpbmsSIS5n",
            "b29nbGUubG9nZ2luZy52Mi5HZXRTaW5rUmVxdWVzdBoaLmdvb2dsZS5sb2dn",
            "aW5nLnYyLkxvZ1NpbmsiKoLT5JMCJBIiL3YyL3tzaW5rX25hbWU9cHJvamVj",
            "dHMvKi9zaW5rcy8qfRJ7CgpDcmVhdGVTaW5rEiQuZ29vZ2xlLmxvZ2dpbmcu",
            "djIuQ3JlYXRlU2lua1JlcXVlc3QaGi5nb29nbGUubG9nZ2luZy52Mi5Mb2dT",
            "aW5rIiuC0+STAiUiHS92Mi97cGFyZW50PXByb2plY3RzLyp9L3NpbmtzOgRz",
            "aW5rEoABCgpVcGRhdGVTaW5rEiQuZ29vZ2xlLmxvZ2dpbmcudjIuVXBkYXRl",
            "U2lua1JlcXVlc3QaGi5nb29nbGUubG9nZ2luZy52Mi5Mb2dTaW5rIjCC0+ST",
            "AioaIi92Mi97c2lua19uYW1lPXByb2plY3RzLyovc2lua3MvKn06BHNpbmsS",
            "dgoKRGVsZXRlU2luaxIkLmdvb2dsZS5sb2dnaW5nLnYyLkRlbGV0ZVNpbmtS",
            "ZXF1ZXN0GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IiqC0+STAiQqIi92Mi97",
            "c2lua19uYW1lPXByb2plY3RzLyovc2lua3MvKn1CgQEKFWNvbS5nb29nbGUu",
            "bG9nZ2luZy52MkISTG9nZ2luZ0NvbmZpZ1Byb3RvUAFaOGdvb2dsZS5nb2xh",
            "bmcub3JnL2dlbnByb3RvL2dvb2dsZWFwaXMvbG9nZ2luZy92Mjtsb2dnaW5n",
            "qgIXR29vZ2xlLkNsb3VkLkxvZ2dpbmcuVjJiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Api.AnnotationsReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.EmptyReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Logging.V2.LogSink), global::Google.Cloud.Logging.V2.LogSink.Parser, new[]{ "Name", "Destination", "Filter", "OutputVersionFormat", "WriterIdentity", "IncludeChildren", "StartTime", "EndTime" }, null, new[]{ typeof(global::Google.Cloud.Logging.V2.LogSink.Types.VersionFormat) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Logging.V2.ListSinksRequest), global::Google.Cloud.Logging.V2.ListSinksRequest.Parser, new[]{ "Parent", "PageToken", "PageSize" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Logging.V2.ListSinksResponse), global::Google.Cloud.Logging.V2.ListSinksResponse.Parser, new[]{ "Sinks", "NextPageToken" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Logging.V2.GetSinkRequest), global::Google.Cloud.Logging.V2.GetSinkRequest.Parser, new[]{ "SinkName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Logging.V2.CreateSinkRequest), global::Google.Cloud.Logging.V2.CreateSinkRequest.Parser, new[]{ "Parent", "Sink", "UniqueWriterIdentity" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Logging.V2.UpdateSinkRequest), global::Google.Cloud.Logging.V2.UpdateSinkRequest.Parser, new[]{ "SinkName", "Sink", "UniqueWriterIdentity" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Google.Cloud.Logging.V2.DeleteSinkRequest), global::Google.Cloud.Logging.V2.DeleteSinkRequest.Parser, new[]{ "SinkName" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Describes a sink used to export log entries to one of the following
  /// destinations in any project: a Cloud Storage bucket, a BigQuery dataset, or a
  /// Cloud Pub/Sub topic.  A logs filter controls which log entries are
  /// exported. The sink must be created within a project, organization, billing
  /// account, or folder.
  /// </summary>
  public sealed partial class LogSink : pb::IMessage<LogSink> {
    private static readonly pb::MessageParser<LogSink> _parser = new pb::MessageParser<LogSink>(() => new LogSink());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LogSink> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Logging.V2.LoggingConfigReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogSink() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogSink(LogSink other) : this() {
      name_ = other.name_;
      destination_ = other.destination_;
      filter_ = other.filter_;
      outputVersionFormat_ = other.outputVersionFormat_;
      writerIdentity_ = other.writerIdentity_;
      includeChildren_ = other.includeChildren_;
      StartTime = other.startTime_ != null ? other.StartTime.Clone() : null;
      EndTime = other.endTime_ != null ? other.EndTime.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LogSink Clone() {
      return new LogSink(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// Required. The client-assigned sink identifier, unique within the
    /// project. Example: `"my-syslog-errors-to-pubsub"`.  Sink identifiers are
    /// limited to 100 characters and can include only the following characters:
    /// upper and lower-case alphanumeric characters, underscores, hyphens, and
    /// periods.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "destination" field.</summary>
    public const int DestinationFieldNumber = 3;
    private string destination_ = "";
    /// <summary>
    /// Required. The export destination:
    ///
    ///     "storage.googleapis.com/[GCS_BUCKET]"
    ///     "bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET]"
    ///     "pubsub.googleapis.com/projects/[PROJECT_ID]/topics/[TOPIC_ID]"
    ///
    /// The sink's `writer_identity`, set when the sink is created, must
    /// have permission to write to the destination or else the log
    /// entries are not exported.  For more information, see
    /// [Exporting Logs With Sinks](/logging/docs/api/tasks/exporting-logs).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Destination {
      get { return destination_; }
      set {
        destination_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "filter" field.</summary>
    public const int FilterFieldNumber = 5;
    private string filter_ = "";
    /// <summary>
    /// Optional.
    /// An [advanced logs filter](/logging/docs/view/advanced_filters).  The only
    /// exported log entries are those that are in the resource owning the sink and
    /// that match the filter. The filter must use the log entry format specified
    /// by the `output_version_format` parameter.  For example, in the v2 format:
    ///
    ///     logName="projects/[PROJECT_ID]/logs/[LOG_ID]" AND severity>=ERROR
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Filter {
      get { return filter_; }
      set {
        filter_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "output_version_format" field.</summary>
    public const int OutputVersionFormatFieldNumber = 6;
    private global::Google.Cloud.Logging.V2.LogSink.Types.VersionFormat outputVersionFormat_ = 0;
    /// <summary>
    /// Optional. The log entry format to use for this sink's exported log
    /// entries.  The v2 format is used by default.
    /// **The v1 format is deprecated** and should be used only as part of a
    /// migration effort to v2.
    /// See [Migration to the v2 API](/logging/docs/api/v2/migration-to-v2).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Logging.V2.LogSink.Types.VersionFormat OutputVersionFormat {
      get { return outputVersionFormat_; }
      set {
        outputVersionFormat_ = value;
      }
    }

    /// <summary>Field number for the "writer_identity" field.</summary>
    public const int WriterIdentityFieldNumber = 8;
    private string writerIdentity_ = "";
    /// <summary>
    /// Output only. An IAM identity&amp;mdash;a service account or group&amp;mdash;under
    /// which Stackdriver Logging writes the exported log entries to the sink's
    /// destination.  This field is set by
    /// [sinks.create](/logging/docs/api/reference/rest/v2/projects.sinks/create)
    /// and
    /// [sinks.update](/logging/docs/api/reference/rest/v2/projects.sinks/update),
    /// based on the setting of `unique_writer_identity` in those methods.
    ///
    /// Until you grant this identity write-access to the destination, log entry
    /// exports from this sink will fail. For more information,
    /// see [Granting access for a
    /// resource](/iam/docs/granting-roles-to-service-accounts#granting_access_to_a_service_account_for_a_resource).
    /// Consult the destination service's documentation to determine the
    /// appropriate IAM roles to assign to the identity.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string WriterIdentity {
      get { return writerIdentity_; }
      set {
        writerIdentity_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "include_children" field.</summary>
    public const int IncludeChildrenFieldNumber = 9;
    private bool includeChildren_;
    /// <summary>
    /// Optional. This field applies only to sinks owned by organizations and
    /// folders. If the field is false, the default, only the logs owned by the
    /// sink's parent resource are available for export. If the field is true, then
    /// logs from all the projects, folders, and billing accounts contained in the
    /// sink's parent resource are also available for export. Whether a particular
    /// log entry from the children is exported depends on the sink's filter
    /// expression. For example, if this field is true, then the filter
    /// `resource.type=gce_instance` would export all Compute Engine VM instance
    /// log entries from all projects in the sink's parent. To only export entries
    /// from certain child projects, filter on the project part of the log name:
    ///
    ///     logName:("projects/test-project1/" OR "projects/test-project2/") AND
    ///     resource.type=gce_instance
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeChildren {
      get { return includeChildren_; }
      set {
        includeChildren_ = value;
      }
    }

    /// <summary>Field number for the "start_time" field.</summary>
    public const int StartTimeFieldNumber = 10;
    private global::Google.Protobuf.WellKnownTypes.Timestamp startTime_;
    /// <summary>
    /// Optional. The time at which this sink will begin exporting log entries.
    /// Log entries are exported only if their timestamp is not earlier than the
    /// start time.  The default value of this field is the time the sink is
    /// created or updated.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp StartTime {
      get { return startTime_; }
      set {
        startTime_ = value;
      }
    }

    /// <summary>Field number for the "end_time" field.</summary>
    public const int EndTimeFieldNumber = 11;
    private global::Google.Protobuf.WellKnownTypes.Timestamp endTime_;
    /// <summary>
    /// Optional. The time at which this sink will stop exporting log entries.  Log
    /// entries are exported only if their timestamp is earlier than the end time.
    /// If this field is not supplied, there is no end time.  If both a start time
    /// and an end time are provided, then the end time must be later than the
    /// start time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp EndTime {
      get { return endTime_; }
      set {
        endTime_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LogSink);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LogSink other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Destination != other.Destination) return false;
      if (Filter != other.Filter) return false;
      if (OutputVersionFormat != other.OutputVersionFormat) return false;
      if (WriterIdentity != other.WriterIdentity) return false;
      if (IncludeChildren != other.IncludeChildren) return false;
      if (!object.Equals(StartTime, other.StartTime)) return false;
      if (!object.Equals(EndTime, other.EndTime)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Destination.Length != 0) hash ^= Destination.GetHashCode();
      if (Filter.Length != 0) hash ^= Filter.GetHashCode();
      if (OutputVersionFormat != 0) hash ^= OutputVersionFormat.GetHashCode();
      if (WriterIdentity.Length != 0) hash ^= WriterIdentity.GetHashCode();
      if (IncludeChildren != false) hash ^= IncludeChildren.GetHashCode();
      if (startTime_ != null) hash ^= StartTime.GetHashCode();
      if (endTime_ != null) hash ^= EndTime.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Destination.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Destination);
      }
      if (Filter.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(Filter);
      }
      if (OutputVersionFormat != 0) {
        output.WriteRawTag(48);
        output.WriteEnum((int) OutputVersionFormat);
      }
      if (WriterIdentity.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(WriterIdentity);
      }
      if (IncludeChildren != false) {
        output.WriteRawTag(72);
        output.WriteBool(IncludeChildren);
      }
      if (startTime_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(StartTime);
      }
      if (endTime_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(EndTime);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Destination.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Destination);
      }
      if (Filter.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Filter);
      }
      if (OutputVersionFormat != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) OutputVersionFormat);
      }
      if (WriterIdentity.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(WriterIdentity);
      }
      if (IncludeChildren != false) {
        size += 1 + 1;
      }
      if (startTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
      }
      if (endTime_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LogSink other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Destination.Length != 0) {
        Destination = other.Destination;
      }
      if (other.Filter.Length != 0) {
        Filter = other.Filter;
      }
      if (other.OutputVersionFormat != 0) {
        OutputVersionFormat = other.OutputVersionFormat;
      }
      if (other.WriterIdentity.Length != 0) {
        WriterIdentity = other.WriterIdentity;
      }
      if (other.IncludeChildren != false) {
        IncludeChildren = other.IncludeChildren;
      }
      if (other.startTime_ != null) {
        if (startTime_ == null) {
          startTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        StartTime.MergeFrom(other.StartTime);
      }
      if (other.endTime_ != null) {
        if (endTime_ == null) {
          endTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        EndTime.MergeFrom(other.EndTime);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 26: {
            Destination = input.ReadString();
            break;
          }
          case 42: {
            Filter = input.ReadString();
            break;
          }
          case 48: {
            outputVersionFormat_ = (global::Google.Cloud.Logging.V2.LogSink.Types.VersionFormat) input.ReadEnum();
            break;
          }
          case 66: {
            WriterIdentity = input.ReadString();
            break;
          }
          case 72: {
            IncludeChildren = input.ReadBool();
            break;
          }
          case 82: {
            if (startTime_ == null) {
              startTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(startTime_);
            break;
          }
          case 90: {
            if (endTime_ == null) {
              endTime_ = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(endTime_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the LogSink message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Available log entry formats. Log entries can be written to Stackdriver
      /// Logging in either format and can be exported in either format.
      /// Version 2 is the preferred format.
      /// </summary>
      public enum VersionFormat {
        /// <summary>
        /// An unspecified format version that will default to V2.
        /// </summary>
        [pbr::OriginalName("VERSION_FORMAT_UNSPECIFIED")] Unspecified = 0,
        /// <summary>
        /// `LogEntry` version 2 format.
        /// </summary>
        [pbr::OriginalName("V2")] V2 = 1,
        /// <summary>
        /// `LogEntry` version 1 format.
        /// </summary>
        [pbr::OriginalName("V1")] V1 = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// The parameters to `ListSinks`.
  /// </summary>
  public sealed partial class ListSinksRequest : pb::IMessage<ListSinksRequest> {
    private static readonly pb::MessageParser<ListSinksRequest> _parser = new pb::MessageParser<ListSinksRequest>(() => new ListSinksRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListSinksRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Logging.V2.LoggingConfigReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListSinksRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListSinksRequest(ListSinksRequest other) : this() {
      parent_ = other.parent_;
      pageToken_ = other.pageToken_;
      pageSize_ = other.pageSize_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListSinksRequest Clone() {
      return new ListSinksRequest(this);
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 1;
    private string parent_ = "";
    /// <summary>
    /// Required. The parent resource whose sinks are to be listed:
    ///
    ///     "projects/[PROJECT_ID]"
    ///     "organizations/[ORGANIZATION_ID]"
    ///     "billingAccounts/[BILLING_ACCOUNT_ID]"
    ///     "folders/[FOLDER_ID]"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "page_token" field.</summary>
    public const int PageTokenFieldNumber = 2;
    private string pageToken_ = "";
    /// <summary>
    /// Optional. If present, then retrieve the next batch of results from the
    /// preceding call to this method.  `pageToken` must be the value of
    /// `nextPageToken` from the previous response.  The values of other method
    /// parameters should be identical to those in the previous call.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PageToken {
      get { return pageToken_; }
      set {
        pageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "page_size" field.</summary>
    public const int PageSizeFieldNumber = 3;
    private int pageSize_;
    /// <summary>
    /// Optional. The maximum number of results to return from this request.
    /// Non-positive values are ignored.  The presence of `nextPageToken` in the
    /// response indicates that more results might be available.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int PageSize {
      get { return pageSize_; }
      set {
        pageSize_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListSinksRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListSinksRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Parent != other.Parent) return false;
      if (PageToken != other.PageToken) return false;
      if (PageSize != other.PageSize) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (PageToken.Length != 0) hash ^= PageToken.GetHashCode();
      if (PageSize != 0) hash ^= PageSize.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (PageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(PageToken);
      }
      if (PageSize != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(PageSize);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (PageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PageToken);
      }
      if (PageSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PageSize);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListSinksRequest other) {
      if (other == null) {
        return;
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.PageToken.Length != 0) {
        PageToken = other.PageToken;
      }
      if (other.PageSize != 0) {
        PageSize = other.PageSize;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 18: {
            PageToken = input.ReadString();
            break;
          }
          case 24: {
            PageSize = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Result returned from `ListSinks`.
  /// </summary>
  public sealed partial class ListSinksResponse : pb::IMessage<ListSinksResponse> {
    private static readonly pb::MessageParser<ListSinksResponse> _parser = new pb::MessageParser<ListSinksResponse>(() => new ListSinksResponse());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ListSinksResponse> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Logging.V2.LoggingConfigReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListSinksResponse() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListSinksResponse(ListSinksResponse other) : this() {
      sinks_ = other.sinks_.Clone();
      nextPageToken_ = other.nextPageToken_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ListSinksResponse Clone() {
      return new ListSinksResponse(this);
    }

    /// <summary>Field number for the "sinks" field.</summary>
    public const int SinksFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Google.Cloud.Logging.V2.LogSink> _repeated_sinks_codec
        = pb::FieldCodec.ForMessage(10, global::Google.Cloud.Logging.V2.LogSink.Parser);
    private readonly pbc::RepeatedField<global::Google.Cloud.Logging.V2.LogSink> sinks_ = new pbc::RepeatedField<global::Google.Cloud.Logging.V2.LogSink>();
    /// <summary>
    /// A list of sinks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Google.Cloud.Logging.V2.LogSink> Sinks {
      get { return sinks_; }
    }

    /// <summary>Field number for the "next_page_token" field.</summary>
    public const int NextPageTokenFieldNumber = 2;
    private string nextPageToken_ = "";
    /// <summary>
    /// If there might be more results than appear in this response, then
    /// `nextPageToken` is included.  To get the next set of results, call the same
    /// method again using the value of `nextPageToken` as `pageToken`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string NextPageToken {
      get { return nextPageToken_; }
      set {
        nextPageToken_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ListSinksResponse);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ListSinksResponse other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!sinks_.Equals(other.sinks_)) return false;
      if (NextPageToken != other.NextPageToken) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= sinks_.GetHashCode();
      if (NextPageToken.Length != 0) hash ^= NextPageToken.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      sinks_.WriteTo(output, _repeated_sinks_codec);
      if (NextPageToken.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(NextPageToken);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += sinks_.CalculateSize(_repeated_sinks_codec);
      if (NextPageToken.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(NextPageToken);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ListSinksResponse other) {
      if (other == null) {
        return;
      }
      sinks_.Add(other.sinks_);
      if (other.NextPageToken.Length != 0) {
        NextPageToken = other.NextPageToken;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            sinks_.AddEntriesFrom(input, _repeated_sinks_codec);
            break;
          }
          case 18: {
            NextPageToken = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The parameters to `GetSink`.
  /// </summary>
  public sealed partial class GetSinkRequest : pb::IMessage<GetSinkRequest> {
    private static readonly pb::MessageParser<GetSinkRequest> _parser = new pb::MessageParser<GetSinkRequest>(() => new GetSinkRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GetSinkRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Logging.V2.LoggingConfigReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetSinkRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetSinkRequest(GetSinkRequest other) : this() {
      sinkName_ = other.sinkName_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GetSinkRequest Clone() {
      return new GetSinkRequest(this);
    }

    /// <summary>Field number for the "sink_name" field.</summary>
    public const int SinkNameFieldNumber = 1;
    private string sinkName_ = "";
    /// <summary>
    /// Required. The resource name of the sink:
    ///
    ///     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
    ///     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
    ///     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
    ///     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
    ///
    /// Example: `"projects/my-project-id/sinks/my-sink-id"`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SinkName {
      get { return sinkName_; }
      set {
        sinkName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GetSinkRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GetSinkRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SinkName != other.SinkName) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SinkName.Length != 0) hash ^= SinkName.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SinkName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(SinkName);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SinkName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SinkName);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GetSinkRequest other) {
      if (other == null) {
        return;
      }
      if (other.SinkName.Length != 0) {
        SinkName = other.SinkName;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            SinkName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The parameters to `CreateSink`.
  /// </summary>
  public sealed partial class CreateSinkRequest : pb::IMessage<CreateSinkRequest> {
    private static readonly pb::MessageParser<CreateSinkRequest> _parser = new pb::MessageParser<CreateSinkRequest>(() => new CreateSinkRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CreateSinkRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Logging.V2.LoggingConfigReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateSinkRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateSinkRequest(CreateSinkRequest other) : this() {
      parent_ = other.parent_;
      Sink = other.sink_ != null ? other.Sink.Clone() : null;
      uniqueWriterIdentity_ = other.uniqueWriterIdentity_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CreateSinkRequest Clone() {
      return new CreateSinkRequest(this);
    }

    /// <summary>Field number for the "parent" field.</summary>
    public const int ParentFieldNumber = 1;
    private string parent_ = "";
    /// <summary>
    /// Required. The resource in which to create the sink:
    ///
    ///     "projects/[PROJECT_ID]"
    ///     "organizations/[ORGANIZATION_ID]"
    ///     "billingAccounts/[BILLING_ACCOUNT_ID]"
    ///     "folders/[FOLDER_ID]"
    ///
    /// Examples: `"projects/my-logging-project"`, `"organizations/123456789"`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Parent {
      get { return parent_; }
      set {
        parent_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "sink" field.</summary>
    public const int SinkFieldNumber = 2;
    private global::Google.Cloud.Logging.V2.LogSink sink_;
    /// <summary>
    /// Required. The new sink, whose `name` parameter is a sink identifier that
    /// is not already in use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Logging.V2.LogSink Sink {
      get { return sink_; }
      set {
        sink_ = value;
      }
    }

    /// <summary>Field number for the "unique_writer_identity" field.</summary>
    public const int UniqueWriterIdentityFieldNumber = 3;
    private bool uniqueWriterIdentity_;
    /// <summary>
    /// Optional. Determines the kind of IAM identity returned as `writer_identity`
    /// in the new sink.  If this value is omitted or set to false, and if the
    /// sink's parent is a project, then the value returned as `writer_identity` is
    /// the same group or service account used by Stackdriver Logging before the
    /// addition of writer identities to this API. The sink's destination must be
    /// in the same project as the sink itself.
    ///
    /// If this field is set to true, or if the sink is owned by a non-project
    /// resource such as an organization, then the value of `writer_identity` will
    /// be a unique service account used only for exports from the new sink.  For
    /// more information, see `writer_identity` in [LogSink][google.logging.v2.LogSink].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UniqueWriterIdentity {
      get { return uniqueWriterIdentity_; }
      set {
        uniqueWriterIdentity_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CreateSinkRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CreateSinkRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Parent != other.Parent) return false;
      if (!object.Equals(Sink, other.Sink)) return false;
      if (UniqueWriterIdentity != other.UniqueWriterIdentity) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Parent.Length != 0) hash ^= Parent.GetHashCode();
      if (sink_ != null) hash ^= Sink.GetHashCode();
      if (UniqueWriterIdentity != false) hash ^= UniqueWriterIdentity.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Parent.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Parent);
      }
      if (sink_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Sink);
      }
      if (UniqueWriterIdentity != false) {
        output.WriteRawTag(24);
        output.WriteBool(UniqueWriterIdentity);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Parent.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Parent);
      }
      if (sink_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sink);
      }
      if (UniqueWriterIdentity != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CreateSinkRequest other) {
      if (other == null) {
        return;
      }
      if (other.Parent.Length != 0) {
        Parent = other.Parent;
      }
      if (other.sink_ != null) {
        if (sink_ == null) {
          sink_ = new global::Google.Cloud.Logging.V2.LogSink();
        }
        Sink.MergeFrom(other.Sink);
      }
      if (other.UniqueWriterIdentity != false) {
        UniqueWriterIdentity = other.UniqueWriterIdentity;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Parent = input.ReadString();
            break;
          }
          case 18: {
            if (sink_ == null) {
              sink_ = new global::Google.Cloud.Logging.V2.LogSink();
            }
            input.ReadMessage(sink_);
            break;
          }
          case 24: {
            UniqueWriterIdentity = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The parameters to `UpdateSink`.
  /// </summary>
  public sealed partial class UpdateSinkRequest : pb::IMessage<UpdateSinkRequest> {
    private static readonly pb::MessageParser<UpdateSinkRequest> _parser = new pb::MessageParser<UpdateSinkRequest>(() => new UpdateSinkRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<UpdateSinkRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Logging.V2.LoggingConfigReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateSinkRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateSinkRequest(UpdateSinkRequest other) : this() {
      sinkName_ = other.sinkName_;
      Sink = other.sink_ != null ? other.Sink.Clone() : null;
      uniqueWriterIdentity_ = other.uniqueWriterIdentity_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public UpdateSinkRequest Clone() {
      return new UpdateSinkRequest(this);
    }

    /// <summary>Field number for the "sink_name" field.</summary>
    public const int SinkNameFieldNumber = 1;
    private string sinkName_ = "";
    /// <summary>
    /// Required. The full resource name of the sink to update, including the
    /// parent resource and the sink identifier:
    ///
    ///     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
    ///     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
    ///     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
    ///     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
    ///
    /// Example: `"projects/my-project-id/sinks/my-sink-id"`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SinkName {
      get { return sinkName_; }
      set {
        sinkName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "sink" field.</summary>
    public const int SinkFieldNumber = 2;
    private global::Google.Cloud.Logging.V2.LogSink sink_;
    /// <summary>
    /// Required. The updated sink, whose name is the same identifier that appears
    /// as part of `sink_name`.  If `sink_name` does not exist, then
    /// this method creates a new sink.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Cloud.Logging.V2.LogSink Sink {
      get { return sink_; }
      set {
        sink_ = value;
      }
    }

    /// <summary>Field number for the "unique_writer_identity" field.</summary>
    public const int UniqueWriterIdentityFieldNumber = 3;
    private bool uniqueWriterIdentity_;
    /// <summary>
    /// Optional. See
    /// [sinks.create](/logging/docs/api/reference/rest/v2/projects.sinks/create)
    /// for a description of this field.  When updating a sink, the effect of this
    /// field on the value of `writer_identity` in the updated sink depends on both
    /// the old and new values of this field:
    ///
    /// +   If the old and new values of this field are both false or both true,
    ///     then there is no change to the sink's `writer_identity`.
    /// +   If the old value is false and the new value is true, then
    ///     `writer_identity` is changed to a unique service account.
    /// +   It is an error if the old value is true and the new value is false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UniqueWriterIdentity {
      get { return uniqueWriterIdentity_; }
      set {
        uniqueWriterIdentity_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as UpdateSinkRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(UpdateSinkRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SinkName != other.SinkName) return false;
      if (!object.Equals(Sink, other.Sink)) return false;
      if (UniqueWriterIdentity != other.UniqueWriterIdentity) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SinkName.Length != 0) hash ^= SinkName.GetHashCode();
      if (sink_ != null) hash ^= Sink.GetHashCode();
      if (UniqueWriterIdentity != false) hash ^= UniqueWriterIdentity.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SinkName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(SinkName);
      }
      if (sink_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Sink);
      }
      if (UniqueWriterIdentity != false) {
        output.WriteRawTag(24);
        output.WriteBool(UniqueWriterIdentity);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SinkName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SinkName);
      }
      if (sink_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sink);
      }
      if (UniqueWriterIdentity != false) {
        size += 1 + 1;
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(UpdateSinkRequest other) {
      if (other == null) {
        return;
      }
      if (other.SinkName.Length != 0) {
        SinkName = other.SinkName;
      }
      if (other.sink_ != null) {
        if (sink_ == null) {
          sink_ = new global::Google.Cloud.Logging.V2.LogSink();
        }
        Sink.MergeFrom(other.Sink);
      }
      if (other.UniqueWriterIdentity != false) {
        UniqueWriterIdentity = other.UniqueWriterIdentity;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            SinkName = input.ReadString();
            break;
          }
          case 18: {
            if (sink_ == null) {
              sink_ = new global::Google.Cloud.Logging.V2.LogSink();
            }
            input.ReadMessage(sink_);
            break;
          }
          case 24: {
            UniqueWriterIdentity = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// The parameters to `DeleteSink`.
  /// </summary>
  public sealed partial class DeleteSinkRequest : pb::IMessage<DeleteSinkRequest> {
    private static readonly pb::MessageParser<DeleteSinkRequest> _parser = new pb::MessageParser<DeleteSinkRequest>(() => new DeleteSinkRequest());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeleteSinkRequest> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Google.Cloud.Logging.V2.LoggingConfigReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteSinkRequest() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteSinkRequest(DeleteSinkRequest other) : this() {
      sinkName_ = other.sinkName_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeleteSinkRequest Clone() {
      return new DeleteSinkRequest(this);
    }

    /// <summary>Field number for the "sink_name" field.</summary>
    public const int SinkNameFieldNumber = 1;
    private string sinkName_ = "";
    /// <summary>
    /// Required. The full resource name of the sink to delete, including the
    /// parent resource and the sink identifier:
    ///
    ///     "projects/[PROJECT_ID]/sinks/[SINK_ID]"
    ///     "organizations/[ORGANIZATION_ID]/sinks/[SINK_ID]"
    ///     "billingAccounts/[BILLING_ACCOUNT_ID]/sinks/[SINK_ID]"
    ///     "folders/[FOLDER_ID]/sinks/[SINK_ID]"
    ///
    /// Example: `"projects/my-project-id/sinks/my-sink-id"`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string SinkName {
      get { return sinkName_; }
      set {
        sinkName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeleteSinkRequest);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeleteSinkRequest other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (SinkName != other.SinkName) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (SinkName.Length != 0) hash ^= SinkName.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (SinkName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(SinkName);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (SinkName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SinkName);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeleteSinkRequest other) {
      if (other == null) {
        return;
      }
      if (other.SinkName.Length != 0) {
        SinkName = other.SinkName;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            SinkName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
